// Generated by Claude, with lots of help from me

import { AsciiRenderConfig } from "../renderConfig";
import { CharacterSamplingData } from "../ascii/generateAsciiChars";
import { SamplingEffect } from "../types";
import { getAlphabetMetadata } from "../alphabets/AlphabetManager";
import {
  PASSTHROUGH_VERTEX_SHADER,
  createSamplingFragmentShader,
  createMaxValueFragmentShader,
  createExternalMaxFragmentShader,
  createDirectionalCrunchFragmentShader,
  createGlobalCrunchFragmentShader,
  COPY_FRAGMENT_SHADER,
} from "./shaders";

interface GPUSamplingDataGeneratorOptions {
  config: AsciiRenderConfig;
  canvasWidth: number;
  canvasHeight: number;
  pixelBufferScale: number;
  samplingQuality: number;
  samplingEffects: SamplingEffect[];
  globalCrunchExponent?: number;
  directionalCrunchExponent?: number;
}

/**
 * GPU-accelerated sampling data generator using WebGL2
 * Replaces CPU-based generateSamplingData for improved performance on mobile
 */
export class GPUSamplingDataGenerator {
  private gl: WebGL2RenderingContext;
  private config: AsciiRenderConfig;
  private canvasWidth: number;
  private canvasHeight: number;
  private pixelBufferScale: number;
  private samplingQuality: number;
  private samplingEffects: SamplingEffect[];
  private numCircles: number;
  private globalCrunchExponent: number;
  private directionalCrunchExponent: number;

  // WebGL resources
  private canvasTexture: WebGLTexture;

  // Framebuffers and textures for multi-pass rendering
  private rawSamplingFBO: WebGLFramebuffer;
  private rawSamplingTexture: WebGLTexture;

  private externalSamplingFBO: WebGLFramebuffer;
  private externalSamplingTexture: WebGLTexture;

  private maxValueFBO: WebGLFramebuffer;
  private maxValueTexture: WebGLTexture;

  private currentSamplingFBO: WebGLFramebuffer;
  private currentSamplingTexture: WebGLTexture;

  private nextSamplingFBO: WebGLFramebuffer;
  private nextSamplingTexture: WebGLTexture;

  // Shader programs
  private samplingProgram: WebGLProgram;
  private externalSamplingProgram: WebGLProgram;
  private copyProgram: WebGLProgram;
  private maxValueProgram: WebGLProgram;
  private externalMaxProgram: WebGLProgram;
  private directionalCrunchProgram: WebGLProgram;
  private globalCrunchProgram: WebGLProgram;

  // External max computation
  private externalMaxFBO: WebGLFramebuffer;
  private externalMaxTexture: WebGLTexture;
  private numExternalPoints: number;
  private affectsMapping: number[];
  private affectsCounts: number[];

  // Vertex array object for fullscreen quad
  private quadVAO: WebGLVertexArrayObject;

  // Pixel Buffer Objects for async readback
  private pbos: WebGLBuffer[];
  private pboSyncs: (WebGLSync | null)[];
  private pboIndex: number;
  private pboInitialized: boolean;

  private readbackBuffer: Float32Array | null = null;

  // Output dimensions
  private outputWidth: number;
  private outputHeight: number;

  constructor(canvas: HTMLCanvasElement, options: GPUSamplingDataGeneratorOptions) {
    const gl = canvas.getContext("webgl2", {
      antialias: false,
      depth: false,
      stencil: false,
      alpha: false,
      premultipliedAlpha: false,
      preserveDrawingBuffer: false,
    });

    if (!gl) {
      throw new Error("WebGL2 not supported");
    }

    this.gl = gl;
    this.config = options.config;
    this.canvasWidth = options.canvasWidth;
    this.canvasHeight = options.canvasHeight;
    this.pixelBufferScale = options.pixelBufferScale;
    this.samplingQuality = options.samplingQuality;
    this.samplingEffects = [...options.samplingEffects];
    if (this.samplingEffects.includes(SamplingEffect.Crunch)) {
      this.samplingEffects.push(SamplingEffect.DirectionalCrunch, SamplingEffect.GlobalCrunch);
    }
    this.globalCrunchExponent = options.globalCrunchExponent ?? 3;
    this.directionalCrunchExponent = options.directionalCrunchExponent ?? 7;

    // Get number of sampling circles from alphabet config
    const metadata = getAlphabetMetadata(this.config.alphabet);
    this.numCircles = metadata.samplingConfig.points.length;

    // Get external points configuration
    const externalPoints =
      "externalPoints" in metadata.samplingConfig
        ? metadata.samplingConfig.externalPoints
        : metadata.samplingConfig.points;
    this.numExternalPoints = externalPoints?.length ?? 0;

    // Build affects mapping for GPU
    const affectsMapping =
      "affectsMapping" in metadata.samplingConfig
        ? metadata.samplingConfig.affectsMapping
        : undefined;
    const { flatMapping, counts } = this.buildAffectsMappingForGPU(affectsMapping, externalPoints);
    this.affectsMapping = flatMapping;
    this.affectsCounts = counts;

    // Calculate output texture dimensions
    // Each cell gets N pixels in a horizontal row (where N = number of circles)
    this.outputWidth = this.config.cols * this.numCircles;
    this.outputHeight = this.config.rows;

    // Initialize WebGL resources
    this.canvasTexture = this.createTexture()!;

    // Create framebuffers and textures
    this.rawSamplingTexture = this.createFloatTexture(this.outputWidth, this.outputHeight)!;
    this.rawSamplingFBO = this.createFramebuffer(this.rawSamplingTexture)!;

    // External sampling texture uses numExternalPoints instead of numCircles
    const externalOutputWidth = this.config.cols * this.numExternalPoints;
    this.externalSamplingTexture = this.createFloatTexture(externalOutputWidth, this.outputHeight)!;
    this.externalSamplingFBO = this.createFramebuffer(this.externalSamplingTexture)!;

    // External max texture (same dimensions as internal sampling: cols*numCircles × rows)
    this.externalMaxTexture = this.createFloatTexture(this.outputWidth, this.outputHeight)!;
    this.externalMaxFBO = this.createFramebuffer(this.externalMaxTexture)!;

    // Max value texture is cols × rows (one pixel per cell)
    this.maxValueTexture = this.createFloatTexture(this.config.cols, this.config.rows)!;
    this.maxValueFBO = this.createFramebuffer(this.maxValueTexture)!;

    // Current and next sampling textures for ping-pong buffering
    this.currentSamplingTexture = this.createFloatTexture(this.outputWidth, this.outputHeight)!;
    this.currentSamplingFBO = this.createFramebuffer(this.currentSamplingTexture)!;

    this.nextSamplingTexture = this.createFloatTexture(this.outputWidth, this.outputHeight)!;
    this.nextSamplingFBO = this.createFramebuffer(this.nextSamplingTexture)!;

    // Compile shaders (generate fragment shaders based on numCircles)
    const samplingFrag = createSamplingFragmentShader(this.numCircles);
    const samplingProgram = this.createProgram(PASSTHROUGH_VERTEX_SHADER, samplingFrag);
    if (!samplingProgram) {
      throw new Error("Failed to create sampling program");
    }
    this.samplingProgram = samplingProgram;

    const externalSamplingFrag = createSamplingFragmentShader(this.numExternalPoints);
    const externalSamplingProgram = this.createProgram(
      PASSTHROUGH_VERTEX_SHADER,
      externalSamplingFrag,
    );
    if (!externalSamplingProgram) {
      throw new Error("Failed to create external sampling program");
    }
    this.externalSamplingProgram = externalSamplingProgram;

    const copyProgram = this.createProgram(PASSTHROUGH_VERTEX_SHADER, COPY_FRAGMENT_SHADER);
    if (!copyProgram) {
      throw new Error("Failed to create copy program");
    }
    this.copyProgram = copyProgram;

    const maxValueFrag = createMaxValueFragmentShader(this.numCircles);
    const maxValueProgram = this.createProgram(PASSTHROUGH_VERTEX_SHADER, maxValueFrag);
    if (!maxValueProgram) {
      throw new Error("Failed to create max value program");
    }
    this.maxValueProgram = maxValueProgram;

    const externalMaxFrag = createExternalMaxFragmentShader(
      this.numCircles,
      this.affectsMapping.length,
    );
    const externalMaxProgram = this.createProgram(PASSTHROUGH_VERTEX_SHADER, externalMaxFrag);
    if (!externalMaxProgram) {
      throw new Error("Failed to create external max program");
    }
    this.externalMaxProgram = externalMaxProgram;

    const directionalCrunchFrag = createDirectionalCrunchFragmentShader();
    const directionalCrunchProgram = this.createProgram(
      PASSTHROUGH_VERTEX_SHADER,
      directionalCrunchFrag,
    );
    if (!directionalCrunchProgram) {
      throw new Error("Failed to create directional crunch program");
    }
    this.directionalCrunchProgram = directionalCrunchProgram;

    const globalCrunchFrag = createGlobalCrunchFragmentShader();
    const globalCrunchProgram = this.createProgram(PASSTHROUGH_VERTEX_SHADER, globalCrunchFrag);
    if (!globalCrunchProgram) {
      throw new Error("Failed to create global crunch program");
    }
    this.globalCrunchProgram = globalCrunchProgram;

    // Create fullscreen quad
    this.quadVAO = this.createQuadVAO()!;

    // Create PBOs for async readback (triple buffering)
    this.pbos = [this.createPBO()!, this.createPBO()!, this.createPBO()!];
    this.pboSyncs = [null, null, null];
    this.pboIndex = 0;
    this.pboInitialized = false;

    // Check for errors
    this.checkGLError("Constructor");
  }

  /**
   * Update exponent values without recreating the generator
   */
  public updateExponents(globalCrunchExponent?: number, directionalCrunchExponent?: number): void {
    if (globalCrunchExponent !== undefined) {
      this.globalCrunchExponent = globalCrunchExponent;
    }
    if (directionalCrunchExponent !== undefined) {
      this.directionalCrunchExponent = directionalCrunchExponent;
    }
  }

  /**
   * Build affects mapping in flat array format for GPU uniforms
   * Prefers affectsMapping from JSON if available, otherwise computes from external points
   */
  private buildAffectsMappingForGPU(
    affectsMapping: number[][] | undefined,
    externalPoints: Array<{ x: number; y: number; affects?: number[] }>,
  ): { flatMapping: number[]; counts: number[] } {
    const numInternalPoints = this.numCircles;
    const counts: number[] = [];
    const flatMapping: number[] = [];

    // Use precomputed mapping from JSON if available
    if (affectsMapping) {
      for (let i = 0; i < numInternalPoints; i++) {
        const affecting = affectsMapping[i] || [];
        counts.push(affecting.length);
        flatMapping.push(...affecting);
      }
    } else {
      // Fallback: compute from external points
      for (let i = 0; i < numInternalPoints; i++) {
        const affectingExternals: number[] = [];

        externalPoints.forEach((extPoint, extIdx) => {
          if (extPoint.affects?.includes(i)) {
            affectingExternals.push(extIdx);
          } else if (!extPoint.affects && extIdx === i) {
            // Backwards compatibility
            affectingExternals.push(extIdx);
          }
        });

        counts.push(affectingExternals.length);
        flatMapping.push(...affectingExternals);
      }
    }

    return { flatMapping, counts };
  }

  /**
   * Update sampling data from a new canvas buffer or HTMLCanvasElement
   */
  public update(
    source: Uint8Array | Uint8ClampedArray | HTMLCanvasElement,
    out: CharacterSamplingData[][],
    pixelBufferScale: number,
    canvasWidth: number,
    canvasHeight: number,
  ): void {
    this.pixelBufferScale = pixelBufferScale;
    this.canvasWidth = canvasWidth;
    this.canvasHeight = canvasHeight;
    this.uploadCanvasTexture(source);

    this.collectRawSamples();
    this.collectExternalSamples();

    const applyDirectionalCrunch = this.samplingEffects.includes(SamplingEffect.DirectionalCrunch);
    if (applyDirectionalCrunch) {
      this.applyDirectionalCrunch();
    }

    const applyGlobalCrunch = this.samplingEffects.includes(SamplingEffect.GlobalCrunch);
    if (applyGlobalCrunch) {
      this.applyGlobalCrunch();
    }

    const isFirefox = typeof navigator !== "undefined" && navigator.userAgent.includes("Firefox");
    if (isFirefox) {
      this.readbackAndParseSync(out);
    } else {
      this.readbackAndParse(out);
    }

    this.checkGLError("Update");
  }

  /**
   * Render raw sampling pass (internal points)
   */
  private collectRawSamples(): void {
    const metadata = getAlphabetMetadata(this.config.alphabet);
    const samplingConfig = metadata.samplingConfig;

    this.renderPass(this.rawSamplingFBO, this.samplingProgram, (program) =>
      this.setSamplingUniforms(program, samplingConfig.points),
    );

    // Copy raw sampling to current buffer (avoids feedback loops in effect passes)
    this.renderPass(this.currentSamplingFBO, this.copyProgram, (program) => {
      const gl = this.gl;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.rawSamplingTexture);
      gl.uniform1i(gl.getUniformLocation(program, "u_inputTexture"), 0);
    });
  }

  /**
   * Render external sampling pass (external points)
   */
  private collectExternalSamples(): void {
    const metadata = getAlphabetMetadata(this.config.alphabet);
    const samplingConfig = metadata.samplingConfig;
    const externalPoints = "externalPoints" in samplingConfig ? samplingConfig.externalPoints : [];

    // Skip if no external points defined
    if (!externalPoints || externalPoints.length === 0) {
      return;
    }

    // External sampling uses different output width
    const externalOutputWidth = this.config.cols * this.numExternalPoints;

    this.renderPass(
      this.externalSamplingFBO,
      this.externalSamplingProgram,
      (program) => this.setSamplingUniforms(program, externalPoints),
      externalOutputWidth,
      this.config.rows,
    );
  }

  /**
   * Apply directional crunch: enhance contrast based on external context
   */
  private applyDirectionalCrunch(): void {
    // Step 1: Compute external max values per internal point
    this.renderPass(this.externalMaxFBO, this.externalMaxProgram, (program) =>
      this.setExternalMaxUniforms(program),
    );

    // Step 2: Apply directional crunch using external max values
    this.renderPass(this.nextSamplingFBO, this.directionalCrunchProgram, (program) =>
      this.setDirectionalCrunchUniforms(program),
    );

    this.swapSamplingBuffers();
  }

  /**
   * Apply global crunch: normalize by cell max value
   * Computes max from current sampling texture (after directional crunch if applied)
   */
  private applyGlobalCrunch(): void {
    // Compute max value per cell from current sampling texture
    this.renderPass(
      this.maxValueFBO,
      this.maxValueProgram,
      (program) => this.setMaxValueUniforms(program),
      this.config.cols,
      this.config.rows,
    );

    // Apply global crunch using max values
    this.renderPass(this.nextSamplingFBO, this.globalCrunchProgram, (program) =>
      this.setGlobalCrunchUniforms(program),
    );
    this.swapSamplingBuffers();
  }

  /**
   * Upload canvas pixel buffer or HTMLCanvasElement to texture
   */
  private uploadCanvasTexture(source: Uint8Array | Uint8ClampedArray | HTMLCanvasElement): void {
    const gl = this.gl;
    gl.bindTexture(gl.TEXTURE_2D, this.canvasTexture);

    if (source instanceof HTMLCanvasElement) {
      // GPU→GPU texture copy - no CPU transfer!
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
    } else {
      // CPU→GPU upload (legacy path for 2D canvas)
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        this.canvasWidth,
        this.canvasHeight,
        0,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        source,
      );
    }
  }

  /**
   * Render a single pass
   */
  private renderPass(
    fbo: WebGLFramebuffer,
    program: WebGLProgram,
    setUniforms: (program: WebGLProgram) => void,
    width?: number,
    height?: number,
  ): void {
    const gl = this.gl;

    // Bind framebuffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.viewport(0, 0, width ?? this.outputWidth, height ?? this.outputHeight);

    // Use program
    gl.useProgram(program);

    // Set uniforms
    setUniforms(program);

    // Draw fullscreen quad
    gl.bindVertexArray(this.quadVAO);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.bindVertexArray(null);
  }

  /**
   * Set uniforms for sampling pass (used for both raw and external)
   */
  private setSamplingUniforms(
    program: WebGLProgram,
    samplingPoints: Array<{ x: number; y: number }>,
  ): void {
    const gl = this.gl;
    const metadata = getAlphabetMetadata(this.config.alphabet);
    const samplingConfig = metadata.samplingConfig;

    // Textures
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.canvasTexture);
    gl.uniform1i(gl.getUniformLocation(program, "u_canvasTexture"), 0);

    // Canvas and grid parameters
    gl.uniform2f(
      gl.getUniformLocation(program, "u_canvasSize"),
      this.canvasWidth,
      this.canvasHeight,
    );
    gl.uniform2f(gl.getUniformLocation(program, "u_gridSize"), this.config.cols, this.config.rows);
    gl.uniform2f(
      gl.getUniformLocation(program, "u_boxSize"),
      this.config.boxWidth,
      this.config.boxHeight,
    );
    gl.uniform2f(
      gl.getUniformLocation(program, "u_gridOffset"),
      this.config.offsetX,
      this.config.offsetY,
    );
    gl.uniform1f(gl.getUniformLocation(program, "u_pixelBufferScale"), this.pixelBufferScale);
    gl.uniform1i(gl.getUniformLocation(program, "u_samplingQuality"), this.samplingQuality);
    gl.uniform1i(gl.getUniformLocation(program, "u_numCircles"), samplingPoints.length);

    // Sampling points
    const pointsLoc = gl.getUniformLocation(program, "u_samplingPoints");
    const points = samplingPoints.flatMap((p) => [p.x, p.y]);
    gl.uniform2fv(pointsLoc, points);

    gl.uniform1f(gl.getUniformLocation(program, "u_circleRadius"), samplingConfig.circleRadius);
  }

  /**
   * Set uniforms for max value pass
   */
  private setMaxValueUniforms(program: WebGLProgram): void {
    const gl = this.gl;

    // Input texture (current sampling vector)
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.currentSamplingTexture);
    gl.uniform1i(gl.getUniformLocation(program, "u_rawSamplingTexture"), 0);

    // Grid size and circle count
    gl.uniform2f(gl.getUniformLocation(program, "u_gridSize"), this.config.cols, this.config.rows);
    gl.uniform1i(gl.getUniformLocation(program, "u_numCircles"), this.numCircles);
  }

  /**
   * Set uniforms for external max computation pass
   */
  private setExternalMaxUniforms(program: WebGLProgram): void {
    const gl = this.gl;

    // External sampling texture
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.externalSamplingTexture);
    gl.uniform1i(gl.getUniformLocation(program, "u_externalSamplingTexture"), 0);

    // Grid parameters
    gl.uniform2f(gl.getUniformLocation(program, "u_gridSize"), this.config.cols, this.config.rows);
    gl.uniform1i(gl.getUniformLocation(program, "u_numCircles"), this.numCircles);
    gl.uniform1i(gl.getUniformLocation(program, "u_numExternalPoints"), this.numExternalPoints);

    // Affects mapping
    gl.uniform1iv(gl.getUniformLocation(program, "u_affectsMapping"), this.affectsMapping);
    gl.uniform1iv(gl.getUniformLocation(program, "u_affectsCounts"), this.affectsCounts);
  }

  /**
   * Set uniforms for directional crunch pass
   */
  private setDirectionalCrunchUniforms(program: WebGLProgram): void {
    const gl = this.gl;

    // Input texture (current sampling vector)
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.currentSamplingTexture);
    gl.uniform1i(gl.getUniformLocation(program, "u_inputTexture"), 0);

    // External max texture (computed from external sampling + affects mapping)
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, this.externalMaxTexture);
    gl.uniform1i(gl.getUniformLocation(program, "u_externalMaxTexture"), 1);

    // Grid size and circle count
    gl.uniform2f(gl.getUniformLocation(program, "u_gridSize"), this.config.cols, this.config.rows);
    gl.uniform1i(gl.getUniformLocation(program, "u_numCircles"), this.numCircles);

    // Directional crunch exponent
    gl.uniform1f(
      gl.getUniformLocation(program, "u_directionalCrunchExponent"),
      this.directionalCrunchExponent,
    );
  }

  /**
   * Set uniforms for global crunch pass
   */
  private setGlobalCrunchUniforms(program: WebGLProgram): void {
    const gl = this.gl;

    // Input texture (current sampling vector)
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.currentSamplingTexture);
    gl.uniform1i(gl.getUniformLocation(program, "u_inputTexture"), 0);

    // Max value texture
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, this.maxValueTexture);
    gl.uniform1i(gl.getUniformLocation(program, "u_maxValueTexture"), 1);

    // Grid size and circle count
    gl.uniform2f(gl.getUniformLocation(program, "u_gridSize"), this.config.cols, this.config.rows);
    gl.uniform1i(gl.getUniformLocation(program, "u_numCircles"), this.numCircles);

    // Global crunch exponent
    gl.uniform1f(
      gl.getUniformLocation(program, "u_globalCrunchExponent"),
      this.globalCrunchExponent,
    );
  }

  /**
   * Swap current and next sampling buffers for ping-pong rendering
   */
  private swapSamplingBuffers(): void {
    const tempTexture = this.currentSamplingTexture;
    const tempFBO = this.currentSamplingFBO;

    this.currentSamplingTexture = this.nextSamplingTexture;
    this.currentSamplingFBO = this.nextSamplingFBO;

    this.nextSamplingTexture = tempTexture;
    this.nextSamplingFBO = tempFBO;
  }

  private readbackAndParseSync(out: CharacterSamplingData[][]): void {
    const gl = this.gl;

    // Allocate or reuse readback buffer
    const requiredSize = this.outputWidth * this.outputHeight * 4;
    if (!this.readbackBuffer || this.readbackBuffer.length !== requiredSize) {
      this.readbackBuffer = new Float32Array(requiredSize);
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentSamplingFBO);
    gl.readPixels(
      0,
      0,
      this.outputWidth,
      this.outputHeight,
      gl.RGBA,
      gl.FLOAT,
      this.readbackBuffer,
    );

    // Parse data into output array
    this.parseReadbackData(this.readbackBuffer, out);
  }

  /**
   * Read back results and parse into CharacterSamplingData using async PBO readback with fences
   */
  private readbackAndParse(out: CharacterSamplingData[][]): void {
    const gl = this.gl;

    // First frame: do synchronous readback to ensure samplingData is populated
    if (!this.pboInitialized) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentSamplingFBO);
      const finalData = new Float32Array(this.outputWidth * this.outputHeight * 4);
      gl.readPixels(0, 0, this.outputWidth, this.outputHeight, gl.RGBA, gl.FLOAT, finalData);

      // Parse data into output array
      this.parseReadbackData(finalData, out);

      // Also write to PBO for next frame
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this.pbos[1]);
      gl.readPixels(0, 0, this.outputWidth, this.outputHeight, gl.RGBA, gl.FLOAT, 0);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);

      // Create fence to signal when GPU completes the transfer
      const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
      gl.flush();
      this.pboSyncs[1] = sync;

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

      // Move to async mode for next frame
      this.pboIndex = 1;
      this.pboInitialized = true;
      return;
    }

    // Subsequent frames: use async PBO readback with fence checking
    const readIndex = this.pboIndex;
    const writeIndex = (this.pboIndex + 1) % 3;

    // Check if the previous frame's PBO is ready to read
    const readSync = this.pboSyncs[readIndex];
    if (readSync) {
      const status = gl.getSyncParameter(readSync, gl.SYNC_STATUS);

      if (status === gl.SIGNALED) {
        // GPU has finished - safe to read
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this.pbos[readIndex]);
        const finalData = new Float32Array(this.outputWidth * this.outputHeight * 4);
        gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, finalData);
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);

        // Parse data into output array
        this.parseReadbackData(finalData, out);

        // Clean up the sync object
        gl.deleteSync(readSync);
        this.pboSyncs[readIndex] = null;
      }
      // If not signaled, skip reading this frame (keep previous samplingData)
    }

    // Before writing, ensure the write buffer is available
    const existingWriteSync = this.pboSyncs[writeIndex];
    if (existingWriteSync) {
      // Wait for the previous write to this buffer to complete
      // Use timeout 0 to avoid INVALID_OPERATION error
      gl.clientWaitSync(existingWriteSync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);
      gl.deleteSync(existingWriteSync);
      this.pboSyncs[writeIndex] = null;
    }

    // Request pixels for the current frame into the next PBO (non-blocking)
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentSamplingFBO);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this.pbos[writeIndex]);
    gl.readPixels(0, 0, this.outputWidth, this.outputHeight, gl.RGBA, gl.FLOAT, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);

    // Create fence for this write
    const writeSync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    gl.flush();
    this.pboSyncs[writeIndex] = writeSync;

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    // Rotate buffers
    this.pboIndex = writeIndex;
  }

  /**
   * Parse readback data into CharacterSamplingData array
   */
  private parseReadbackData(finalData: Float32Array, out: CharacterSamplingData[][]): void {
    // Data is packed as: 3 circles per row, 2 rows per cell
    // Each pixel contains one sampling value in the red channel

    // Ensure output array is properly initialized
    for (let row = 0; row < this.config.rows; row++) {
      if (!out[row]) {
        out[row] = [];
      }
      for (let col = 0; col < this.config.cols; col++) {
        if (!out[row][col]) {
          out[row][col] = {
            samplingVector: [],
            rawSamplingVector: [],
            externalSamplingVector: [],
            samplingVectorSubsamples: [],
            character: null,
          };
        }

        const samplingVector: number[] = [];
        const rawSamplingVector: number[] = [];
        const externalSamplingVector: number[] = [];

        // Read N circles for this cell (N = numCircles)
        for (let circleIdx = 0; circleIdx < this.numCircles; circleIdx++) {
          // Reverse circle order - texture stores them backwards
          const pixelX = col * this.numCircles + (this.numCircles - 1 - circleIdx);
          const pixelY = row;

          const pixelIndex = (pixelY * this.outputWidth + pixelX) * 4;

          // Read from all three textures
          // Crunch is now applied in GPU shader, so read final values from crunchedData
          samplingVector.push(finalData[pixelIndex]); // Final crunched value
        }

        // Update output array (note: subsamples not collected in GPU path)
        out[row][col].samplingVector = samplingVector;
        out[row][col].rawSamplingVector = rawSamplingVector;
        out[row][col].externalSamplingVector = externalSamplingVector;
        out[row][col].samplingVectorSubsamples = []; // Not collected in GPU path
      }
    }
  }

  /**
   * Create a 2D texture
   */
  private createTexture(): WebGLTexture | null {
    const gl = this.gl;
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    return texture;
  }

  /**
   * Create a float texture for rendering
   */
  private createFloatTexture(width: number, height: number): WebGLTexture | null {
    const gl = this.gl;

    // Check if float texture filtering is supported
    const ext = gl.getExtension("EXT_color_buffer_float");
    if (!ext) {
      console.warn("EXT_color_buffer_float not supported, GPU acceleration may not work");
    }

    const texture = this.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, null);
    return texture;
  }

  /**
   * Create a framebuffer with texture attachment
   */
  private createFramebuffer(texture: WebGLTexture): WebGLFramebuffer | null {
    const gl = this.gl;
    const fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
      const statusName =
        {
          [gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT]: "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
          [gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT]:
            "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
          [gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS]: "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
          [gl.FRAMEBUFFER_UNSUPPORTED]: "FRAMEBUFFER_UNSUPPORTED",
          [gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE]: "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",
        }[status] || `UNKNOWN (${status})`;

      console.error("Framebuffer not complete:", statusName);
      console.error("This usually means RGBA32F textures are not supported for rendering.");
      console.error("Try enabling EXT_color_buffer_float extension.");
      return null;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return fbo;
  }

  /**
   * Compile and link shader program
   */
  private createProgram(vertexSource: string, fragmentSource: string): WebGLProgram | null {
    const gl = this.gl;

    const vertexShader = this.compileShader(gl.VERTEX_SHADER, vertexSource);
    const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fragmentSource);

    if (!vertexShader || !fragmentShader) {
      console.error("Failed to compile shaders");
      if (vertexShader) gl.deleteShader(vertexShader);
      if (fragmentShader) gl.deleteShader(fragmentShader);
      return null;
    }

    const program = gl.createProgram();
    if (!program) {
      console.error("Failed to create program object");
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      return null;
    }

    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    // Shaders can be deleted after linking
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Program link error:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }

    return program;
  }

  /**
   * Compile a shader
   */
  private compileShader(type: number, source: string): WebGLShader | null {
    const gl = this.gl;
    const shader = gl.createShader(type);
    if (!shader) {
      console.error("Failed to create shader object");
      return null;
    }

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      const shaderType = type === gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT";
      console.error(`${shaderType} shader compile error:`, gl.getShaderInfoLog(shader));
      console.error("Shader source (first 500 chars):", source.substring(0, 500));
      gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  /**
   * Create VAO for fullscreen quad
   */
  private createQuadVAO(): WebGLVertexArrayObject | null {
    const gl = this.gl;

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    // Fullscreen quad vertices (triangle strip)
    const vertices = new Float32Array([
      -1,
      -1, // Bottom-left
      1,
      -1, // Bottom-right
      -1,
      1, // Top-left
      1,
      1, // Top-right
    ]);

    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    // Position attribute
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    gl.bindVertexArray(null);
    return vao;
  }

  /**
   * Create a Pixel Buffer Object for async readback
   */
  private createPBO(): WebGLBuffer | null {
    const gl = this.gl;
    const pbo = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);

    // Allocate buffer size for RGBA32F data
    const bufferSize = this.outputWidth * this.outputHeight * 4 * 4; // 4 floats per pixel
    gl.bufferData(gl.PIXEL_PACK_BUFFER, bufferSize, gl.STREAM_READ);

    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    return pbo;
  }

  /**
   * Check for GL errors
   */
  private checkGLError(context: string): void {
    if (process.env.NODE_ENV === "development") {
      const gl = this.gl;
      const error = gl.getError();
      if (error !== gl.NO_ERROR) {
        console.error(`WebGL error in ${context}:`, error);
      }
    }
  }

  /**
   * Clean up WebGL resources
   */
  public dispose(): void {
    const gl = this.gl;

    // Delete textures
    gl.deleteTexture(this.canvasTexture);
    gl.deleteTexture(this.rawSamplingTexture);
    gl.deleteTexture(this.externalSamplingTexture);
    gl.deleteTexture(this.externalMaxTexture);
    gl.deleteTexture(this.maxValueTexture);
    gl.deleteTexture(this.currentSamplingTexture);
    gl.deleteTexture(this.nextSamplingTexture);

    // Delete framebuffers
    gl.deleteFramebuffer(this.rawSamplingFBO);
    gl.deleteFramebuffer(this.externalSamplingFBO);
    gl.deleteFramebuffer(this.externalMaxFBO);
    gl.deleteFramebuffer(this.maxValueFBO);
    gl.deleteFramebuffer(this.currentSamplingFBO);
    gl.deleteFramebuffer(this.nextSamplingFBO);

    // Delete programs
    gl.deleteProgram(this.samplingProgram);
    gl.deleteProgram(this.externalSamplingProgram);
    gl.deleteProgram(this.copyProgram);
    gl.deleteProgram(this.maxValueProgram);
    gl.deleteProgram(this.externalMaxProgram);
    gl.deleteProgram(this.directionalCrunchProgram);
    gl.deleteProgram(this.globalCrunchProgram);

    // Delete VAO
    gl.deleteVertexArray(this.quadVAO);

    // Delete PBOs
    this.pbos.forEach((pbo) => gl.deleteBuffer(pbo));

    // Delete sync objects
    this.pboSyncs.forEach((sync) => {
      if (sync) gl.deleteSync(sync);
    });
  }
}
