// Generated by Claude, based on FocusedScriptContext

import React, { useEffect, useMemo, useRef, useState } from "react";

export const ActiveAsciiSceneContext = React.createContext({ activeSceneId: "" });

interface Item {
  top: number;
  height: number;
  bottom: number;
  sceneId: string;
}

export const ActiveAsciiSceneProvider = (props: { children: React.ReactNode }) => {
  const [sceneId, setSceneId] = useState("");
  const sceneIdRef = useRef(sceneId);
  sceneIdRef.current = sceneId;

  const itemsRef = useRef<Item[]>([]);
  const fetchedItemsAtRef = useRef(0);

  useEffect(() => {
    const getItems = () => {
      const els = document.querySelectorAll("[data-ascii-scene-id]");

      const items: Item[] = [];
      itemsRef.current = items;

      els.forEach((el) => {
        const { top: _top, height } = el.getBoundingClientRect();
        const sceneId = el.getAttribute("data-ascii-scene-id")!;
        const top = window.scrollY + _top;
        const bottom = top + height;
        items.push({ top, height, bottom, sceneId });
      });
    };

    const recalcActive = (force?: boolean) => {
      const timeSinceFetched = Date.now() - fetchedItemsAtRef.current;
      if (force || timeSinceFetched > 2000) {
        getItems();
        fetchedItemsAtRef.current = Date.now();
      }

      let activeItem: Item | null = null;

      const y1 = window.scrollY;
      const y2 = window.scrollY + window.innerHeight;
      const viewportHeight = window.innerHeight;

      const buf = viewportHeight * 0.05;
      const bounds: [number, number] = [y1, y2 - buf];
      const centerMark = y1 + viewportHeight * 0.5;

      const heightExceedsBounds = (height: number, bounds: [number, number]) => {
        const [top, bottom] = bounds;
        const diff = bottom - top;
        return height > diff;
      };

      const getVisiblePortion = (item: Item) => {
        const visibleTop = Math.max(item.top, y1);
        const visibleBottom = Math.min(item.bottom, y2);
        const visibleHeight = Math.max(0, visibleBottom - visibleTop);
        const sceneCoverage = visibleHeight / item.height;
        return { sceneCoverage, visibleHeight };
      };

      const containsCenter = (item: Item) => {
        const itemCenter = item.top + item.height / 2;
        return itemCenter > y1 && itemCenter < y2;
      };

      const containsViewportCenter = (item: Item) => {
        return centerMark > item.top && centerMark < item.bottom;
      };

      for (const item of itemsRef.current) {
        const { sceneCoverage } = getVisiblePortion(item);

        const itemCenter = item.top + item.height / 2;
        const isAboveCenter = itemCenter < centerMark;

        const sceneCoverageThreshold = 0.8;

        if (heightExceedsBounds(item.height, bounds) && containsViewportCenter(item)) {
          activeItem = item;
        } else if (isAboveCenter && sceneCoverage > sceneCoverageThreshold) {
          activeItem = item;
        } else if (!isAboveCenter && containsCenter(item)) {
          activeItem = item;
        }

        if (activeItem) break;
      }

      const sceneId = activeItem?.sceneId || "";
      if (sceneIdRef.current !== sceneId) setSceneId(sceneId);
    };

    const listener = () => recalcActive();

    window.addEventListener("scroll", listener);
    window.addEventListener("resize", listener);

    const timeoutIds: number[] = [];

    recalcActive(true);
    timeoutIds.push(window.setTimeout(() => recalcActive(true), 16));
    timeoutIds.push(window.setTimeout(() => recalcActive(true), 100));

    return () => {
      window.removeEventListener("scroll", listener);
      window.removeEventListener("resize", listener);
      timeoutIds.forEach((id) => window.clearTimeout(id));
    };
  }, []);

  const value = useMemo(() => ({ activeSceneId: sceneId }), [sceneId]);

  return (
    <ActiveAsciiSceneContext.Provider value={value}>
      {props.children}
    </ActiveAsciiSceneContext.Provider>
  );
};
