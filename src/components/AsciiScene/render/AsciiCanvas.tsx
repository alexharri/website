// Generated by Claude, with help from me

import React, { useRef, useCallback, useEffect, useMemo } from "react";
import { CharacterSamplingData } from "../sampling/cpu/generateAsciiChars";
import { AsciiRenderConfig } from "../renderConfig";
import { CharacterMatcher } from "../characterLookup/CharacterMatcher";
import { cssVariables } from "../../../utils/cssVariables";

interface Props {
  canvasRef: React.MutableRefObject<HTMLCanvasElement | null>;
  transform?: string;
}

export function AsciiCanvas(props: Props) {
  return (
    <canvas
      ref={props.canvasRef}
      style={{
        position: "absolute",
        top: 0,
        left: 0,
        pointerEvents: "none",
        transform: props.transform,
      }}
    />
  );
}

interface RenderState {
  chars: string[][];
  rows: number;
  cols: number;
}

export function useAsciiCanvas(
  canvasRef: React.RefObject<HTMLCanvasElement>,
  config: AsciiRenderConfig | null,
  color: string,
) {
  const previousRenderStateRef = useRef<RenderState | null>(null);

  const glyphCache = useMemo(() => {
    return new Map<string, HTMLCanvasElement>();
  }, [color, config?.fontSize, config?.boxWidth, config?.boxHeight]);
  const glyphCacheRef = useRef(glyphCache);
  glyphCacheRef.current = glyphCache;

  const getOrCreateGlyph = useCallback(
    (char: string, dpr: number): HTMLCanvasElement => {
      const cacheKey = `${char}_${dpr}`;

      let cached = glyphCacheRef.current.get(cacheKey);
      if (cached) return cached;

      const { fontSize, boxWidth, boxHeight } = config!;

      const glyphCanvas = document.createElement("canvas");
      const measureCanvas = document.createElement("canvas");
      const measureCtx = measureCanvas.getContext("2d");
      if (!measureCtx) {
        return glyphCanvas;
      }

      measureCtx.font = `${fontSize}px ${cssVariables.fontMonospace}`;

      const width = boxWidth;
      const height = boxHeight;

      glyphCanvas.width = width * dpr;
      glyphCanvas.height = height * dpr;

      const ctx = glyphCanvas.getContext("2d");
      if (!ctx) return glyphCanvas;

      ctx.scale(dpr, dpr);
      ctx.font = `${fontSize}px ${cssVariables.fontMonospace}`;
      ctx.textBaseline = "top";
      ctx.fillStyle = color;
      ctx.fillText(char, 0, 0);

      glyphCacheRef.current.set(cacheKey, glyphCanvas);
      return glyphCanvas;
    },
    [config?.fontSize, config?.boxWidth, config?.boxHeight],
  );

  const render = useCallback(
    (samplingData: CharacterSamplingData[][], characterMatcher: CharacterMatcher) => {
      const canvas = canvasRef.current;
      if (!canvas || !config) return;

      const ctx = canvas.getContext("2d", { desynchronized: true });
      if (!ctx) return;

      ctx.imageSmoothingEnabled = false;
      const dpr = window.devicePixelRatio;

      const dimensionsChanged =
        !previousRenderStateRef.current ||
        previousRenderStateRef.current.rows !== config.rows ||
        previousRenderStateRef.current.cols !== config.cols;

      if (dimensionsChanged) {
        canvas.width = config.canvasWidth * dpr;
        canvas.height = config.canvasHeight * dpr;
        canvas.style.width = config.canvasWidth + "px";
        canvas.style.height = config.canvasHeight + "px";

        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, config.canvasWidth, config.canvasHeight);

        previousRenderStateRef.current = {
          chars: Array.from({ length: config.rows }, () => Array(config.cols).fill("")),
          rows: config.rows,
          cols: config.cols,
        };
      }

      const { boxWidth, boxHeight } = config;

      for (let row = 0; row < config.rows; row++) {
        for (let col = 0; col < config.cols; col++) {
          const cellSamplingData = samplingData[row]?.[col];
          if (!cellSamplingData) continue;

          const selectedChar = characterMatcher.findBestCharacterQuantized(
            cellSamplingData.samplingVector,
          );

          const prevChar = previousRenderStateRef.current!.chars[row]?.[col];
          if (dimensionsChanged || selectedChar !== prevChar) {
            const x = col * boxWidth;
            const y = row * boxHeight;

            const glyph = getOrCreateGlyph(selectedChar, dpr);
            ctx.clearRect(x, y, boxWidth, boxHeight);
            ctx.drawImage(glyph, x, y, boxWidth, boxHeight);

            previousRenderStateRef.current!.chars[row][col] = selectedChar;
          }
        }
      }
    },
    [canvasRef, config, color, getOrCreateGlyph],
  );

  useEffect(() => {
    return () => glyphCacheRef.current.clear();
  }, []);

  return { render };
}
