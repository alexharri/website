// Generated by Claude

import { CharacterSamplingData } from "../sampling/cpu/generateAsciiChars";
import { getAlphabetMetadata } from "../alphabets";
import { AsciiRenderConfig } from "../renderConfig";
import { DebugVizOptions } from "../types";
import { colors } from "../../../utils/cssVariables";
import { hexToRgbaString } from "../../../utils/color";
import { useEffect, useRef } from "react";
import { Observer } from "../../../utils/observer";

interface Props {
  config: AsciiRenderConfig | null;
  debugVizOptions: DebugVizOptions;
  samplingDataObserver: Observer<CharacterSamplingData[][]>;
  hideSpaces: boolean;
  forceSamplingValue: number | undefined;
}

const TAU = 2 * Math.PI;

export function AsciiDebugVizCanvas(props: Props) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const { samplingDataObserver, config, debugVizOptions, hideSpaces, forceSamplingValue } = props;

  useEffect(() => {
    function onData(samplingData: CharacterSamplingData[][]) {
      if (!config || !canvasRef.current) return;
      renderAsciiDebugViz(
        canvasRef.current,
        samplingData,
        config,
        debugVizOptions,
        hideSpaces,
        forceSamplingValue,
      );
    }
    const unsubscribe = samplingDataObserver.subscribe(onData);
    return unsubscribe;
  }, [samplingDataObserver, config, debugVizOptions, hideSpaces, forceSamplingValue]);

  return (
    <canvas
      ref={canvasRef}
      style={{
        position: "absolute",
        top: 0,
        left: 0,
        pointerEvents: "none",
        zIndex: 50,
        imageRendering: "crisp-edges", // Avoid blurry canvas on iOS
      }}
    />
  );
}

function renderAsciiDebugViz(
  canvas: HTMLCanvasElement,
  samplingData: CharacterSamplingData[][],
  config: AsciiRenderConfig,
  options: DebugVizOptions,
  hideSpaces: boolean,
  forceSamplingValue?: number,
) {
  const ctx = canvas.getContext("2d");
  if (!ctx) return;

  const dpr = window.devicePixelRatio || 1;

  canvas.width = config.canvasWidth * dpr;
  canvas.height = config.canvasHeight * dpr;
  canvas.style.width = config.canvasWidth + "px";
  canvas.style.height = config.canvasHeight + "px";

  ctx.scale(dpr, dpr);

  ctx.clearRect(0, 0, config.canvasWidth, config.canvasHeight);

  const metadata = getAlphabetMetadata(config.alphabet);

  const circleSamplingPoints = config.generateCircleSamplingPoints();

  const samplingPointRadius = 2.5;

  if (options.showGrid) {
    const thickness = options.showGrid === "dark" ? 2 : 1;
    const offset = -(1 - thickness) / 2;
    ctx.fillStyle =
      options.showGrid === "dark" ? colors.background : hexToRgbaString(colors.blue, 0.5);
    ctx.beginPath();
    for (let row = 1; row < config.rows; row++) {
      const y = config.offsetY + config.boxHeight * row;
      if (Math.abs(y) < thickness || Math.abs(y - config.canvasHeight) < thickness) continue;
      ctx.rect(0, y + offset, config.canvasWidth, thickness);
    }
    for (let col = 1; col < config.cols; col++) {
      const x = config.offsetX + config.boxWidth * col;
      if (Math.abs(x) < thickness || Math.abs(x - config.canvasWidth) < thickness) continue;
      ctx.rect(x + offset, 0, thickness, config.canvasHeight);
    }
    ctx.fill();
  }

  const externalPoints =
    "externalPoints" in metadata.samplingConfig ? metadata.samplingConfig.externalPoints : [];

  for (let col = 0; col < config.cols; col++) {
    for (let row = 0; row < config.rows; row++) {
      if (hideSpaces) {
        const everyValueZero = samplingData[row][col].samplingVector.every((v) => v === 0);
        if (everyValueZero) continue;
      }

      const [sampleRectLeft, sampleRectTop] = config.sampleRectPosition(col, row);
      if (options.showSamplingCircles || options.showSamplingPoints) {
        const samplingVector = samplingData[row][col];
        metadata.samplingConfig.points.forEach((samplingCircle, i) => {
          const [xOff, yOff] = config.samplingCircleOffset(samplingCircle);
          const x = sampleRectLeft + xOff;
          const y = sampleRectTop + yOff;

          if (options.showSamplingCircles) {
            let color = "rgba(255, 255, 255, 0.33)";
            switch (options.samplingCirclesColor) {
              case "blue":
                color = colors.blue200;
                break;
              case "white":
                color = colors.text;
                break;
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x, y, config.samplePointRadius, 0, TAU);
            ctx.stroke();

            const vectorToUse = samplingVector.rawSamplingVector;
            const value = forceSamplingValue ?? vectorToUse[i];
            const intensity = value * 0.7;
            ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
            ctx.beginPath();
            ctx.arc(x, y, config.samplePointRadius, 0, TAU);
            ctx.fill();
          }

          if (options.showSamplingPoints) {
            ctx.fillStyle = colors.blue200;
            for (const point of circleSamplingPoints) {
              ctx.beginPath();
              ctx.arc(x + point.x, y + point.y, samplingPointRadius + 1.25, 0, TAU);
              ctx.fill();
            }

            const subsamples = samplingVector.samplingVectorSubsamples[i];
            circleSamplingPoints.forEach((point, pointIndex) => {
              const value = subsamples?.[pointIndex] ?? 0;
              const lightness = Math.floor(value * 255);
              ctx.fillStyle = `rgb(${lightness}, ${lightness}, ${lightness})`;

              ctx.beginPath();
              ctx.arc(x + point.x, y + point.y, samplingPointRadius, 0, TAU);
              ctx.fill();
              ctx.closePath();
            });
          }
        });
      }

      if (options.showExternalSamplingCircles) {
        const samplingVector = samplingData[row][col];
        externalPoints.forEach((samplingCircle, i) => {
          const [xOff, yOff] = config.samplingCircleOffset(samplingCircle);
          const x = sampleRectLeft + xOff;
          const y = sampleRectTop + yOff;

          ctx.strokeStyle = "rgba(255, 255, 255, 0.33)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(x, y, config.samplePointRadius, 0, TAU);
          ctx.stroke();

          const vectorToUse = samplingVector.externalSamplingVector;
          const value = forceSamplingValue ?? vectorToUse[i];
          const intensity = value * 0.7;
          ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
          ctx.beginPath();
          ctx.arc(x, y, config.samplePointRadius, 0, TAU);
          ctx.fill();
        });
      }
    }
  }
}
